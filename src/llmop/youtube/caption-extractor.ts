// Caption extractor for YouTube videos
// This module extracts captions from YouTube videos using in-browser techniques

// Extend the Window interface to include YouTube-specific properties
declare global {
  interface Window {
    ytInitialPlayerResponse?: YouTubePlayerResponse;
  }
}

// Define interfaces for YouTube player response structure
interface YouTubePlayerResponse {
  captions?: {
    playerCaptionsTracklistRenderer?: {
      captionTracks?: CaptionTrack[];
    };
  };
  // Add other properties as needed
}

interface CaptionTrack {
  baseUrl: string;
  vssId: string;
  languageCode: string;
  kind?: string;
  name?: {
    simpleText?: string;
  };
  // Add other properties as needed
}

import { createLogger } from '../core/debug';
import { extractVideoId } from '../utils/url-utils';
import GM_fetch from '@trim21/gm-fetch';

// Create a logger for this module
const logger = createLogger('CaptionExtractor');

// Interface for the response from the caption extraction
export interface CaptionExtractionResult {
  transcript: string;
  language?: string;
  isAutoGenerated?: boolean;
  elapsed_time_ms: number;
}

/**
 * Helper function to parse simple XML timed text (like YouTube's TTML)
 * Uses DOMParser for more robust XML handling.
 */
function parseSimpleXmlTimedText(xmlContent: string): string {
  try {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
    const textNodes = xmlDoc.getElementsByTagName('text');
    let transcript = '';

    for (let i = 0; i < textNodes.length; i++) {
      const textContent = textNodes[i].textContent;
      if (textContent) {
        // The browser's parser automatically handles HTML entities like &#39;
        transcript +=
          textContent.trim() +
          ` # start=${textNodes[i].getAttribute('start')}s duration=${textNodes[i].getAttribute('dur')}s\n`;
      }
    }
    return transcript.trim();
  } catch (error) {
    logger.error('Error parsing XML timed text:', error);
    return 'Failed to parse transcript XML.';
  }
}

/**
 * Extract the ytInitialPlayerResponse from the current page
 * This works by finding the script tag that contains the player response
 */
async function extractVideoData(url: string): Promise<YouTubePlayerResponse> {
  try {
    logger.info(`Requesting ${url} for video data`);
    const result = await GM_fetch(url, { method: 'GET' });

    logger.info('Extracting ytInitialPlayerResponse from page HTML');
    const html = await result.text();

    logger.log(html);

    const jsonStartMarker = 'var ytInitialPlayerResponse = {';
    const jsonEndMarker = '};';

    const startIndex = html.indexOf(jsonStartMarker);
    if (startIndex === -1) {
      throw new Error(
        'Could not find ytInitialPlayerResponse JSON start marker.',
      );
    }
    logger.info(`Found start index: ${startIndex}`);

    const jsonStringStart = html.substring(
      startIndex + jsonStartMarker.length - 1,
    ); // Include the starting '{'
    const endIndex = jsonStringStart.indexOf(jsonEndMarker);
    if (endIndex === -1) {
      throw new Error(
        'Could not find ytInitialPlayerResponse JSON end marker.',
      );
    }
    logger.info(`Found end index: ${endIndex}`);

    const jsonString = jsonStringStart.substring(0, endIndex + 1); // Include the ending '}'
    logger.info(`Extracted potential JSON string length: ${jsonString.length}`);

    return JSON.parse(jsonString) as YouTubePlayerResponse;
  } catch (error) {
    logger.error('Error extracting player response:', error);
    throw new Error(`Failed to extract player response: ${error}`);
  }
}

/**
 * Extract captions for a YouTube video
 * @param videoId The YouTube video ID
 * @returns A promise that resolves to the caption extraction result
 */
export async function extractCaptions(
  videoId: string,
): Promise<CaptionExtractionResult> {
  logger.info(`Starting caption extraction for video ID: ${videoId}`);
  const startTime = Date.now();

  try {
    // 1. Get the player response
    const playerResponse = await extractVideoData(
      `https://www.youtube.com/watch?v=${videoId}`,
    );
    logger.info('Successfully extracted player response');

    // 2. Find caption tracks
    const captionTracks =
      playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    if (
      !captionTracks ||
      !Array.isArray(captionTracks) ||
      captionTracks.length === 0
    ) {
      logger.info('No caption tracks found in player response');
      GM.notification({
        title: 'LLMOP YouTube',
        text: 'No captions available for this video.',
        image: 'https://www.youtube.com/favicon.ico',
      });
      return {
        transcript: 'No captions available for this video.',
        elapsed_time_ms: Date.now() - startTime,
      };
    }

    logger.info(`Found ${captionTracks.length} caption track(s)`);

    // 3. Select the best caption track
    let bestTrack: CaptionTrack | null = null;
    const preferredLang = 'en';

    // Prioritize non-ASR English
    bestTrack = captionTracks.find(
      (track) => track.languageCode === preferredLang && track.kind !== 'asr',
    );
    let isAutoGenerated = false;

    if (bestTrack) {
      logger.info(`Selected standard English track: ${bestTrack.vssId}`);
    } else {
      // Fallback to ASR English
      bestTrack = captionTracks.find(
        (track) => track.languageCode === preferredLang && track.kind === 'asr',
      );
      if (bestTrack) {
        logger.info(
          `Selected auto-generated English track: ${bestTrack.vssId}`,
        );
        isAutoGenerated = true;
      } else {
        // Fallback to the first track available
        bestTrack = captionTracks[0];
        if (bestTrack) {
          logger.info(
            `Selected first available track: ${bestTrack.vssId} (lang: ${bestTrack.languageCode})`,
          );
        }
      }
    }

    if (!bestTrack) {
      logger.info('No suitable caption track found');
      GM.notification({
        title: 'LLMOP YouTube',
        text: 'Could not find a usable caption track.',
        image: 'https://www.youtube.com/favicon.ico',
      });
      return {
        transcript: 'Could not retrieve caption data.',
        elapsed_time_ms: Date.now() - startTime,
      };
    }

    // 4. Fetch the caption file
    const captionUrl = bestTrack.baseUrl;
    logger.info(`Fetching caption file from: ${captionUrl}`);

    const response = await fetch(captionUrl);
    if (!response.ok) {
      throw new Error(
        `Failed to download captions. Status: ${response.status}`,
      );
    }

    const captionContent = await response.text();
    logger.info(`Downloaded caption content length: ${captionContent.length}`);

    // 5. Parse the caption file
    logger.info('Parsing caption content...');
    const transcript = parseSimpleXmlTimedText(captionContent);
    logger.info(`Parsed transcript length: ${transcript.length}`);

    if (!transcript) {
      logger.info('Transcript parsing resulted in empty content');
      return {
        transcript: 'Transcript extracted, but it was empty.',
        elapsed_time_ms: Date.now() - startTime,
      };
    }

    // 6. Return successful response
    logger.info('Successfully extracted captions');
    return {
      transcript,
      language: bestTrack.languageCode,
      isAutoGenerated,
      elapsed_time_ms: Date.now() - startTime,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : `${error}`;
    logger.error(`Error extracting captions: ${errorMessage}`, error);
    GM.notification({
      title: 'LLMOP YouTube',
      text: `Error extracting captions: ${errorMessage}`,
      image: 'https://www.youtube.com/favicon.ico',
    });
    return {
      transcript: `Error extracting captions: ${errorMessage}`,
      elapsed_time_ms: Date.now() - startTime,
    };
  }
}

/**
 * Extract captions for the current YouTube video page
 * @returns A promise that resolves to the caption extraction result, or null if not on a watch page
 */
export async function extractCaptionsForCurrentPage(): Promise<CaptionExtractionResult | null> {
  try {
    // Check if we're on a YouTube watch page
    const url = window.location.href;
    const videoId = extractVideoId(url);

    if (!videoId) {
      logger.info("Not on a YouTube watch page or couldn't extract video ID");
      return null;
    }

    return await extractCaptions(videoId);
  } catch (error) {
    const errorMessage = `${error instanceof Error ? error.message : error}`;
    logger.error(
      `Error in extractCaptionsForCurrentPage: ${errorMessage}`,
      error,
    );
    return null;
  }
}
